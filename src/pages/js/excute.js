


const javascript_excution_context = () => {
    /* 
      执行上下文：
        执行上下文是JavaScript引擎内部用于管理和执行代码的数据结构
        三种执行上下文： 全局执行上下文、函数执行上下文、eval执行上下文

      执行栈：
        管理执行期间所有执行上下文的数据结构，也就是js程序的调用栈
        程序开始时会创建一个全局执行上下文（GlobalContext）压入栈中，之后每当有函数调用就创建一个函数执行上下文压入栈中。
      
      执行上下文的结构：

      GlobalExecutionContext = {
            // 环境记录可以包含变量标识符与变量值之间的映射关系，以支持变量的声明和访问。
            // 变量环境本质上仍是词法环境，但它只存储var声明的变量，这样在初始化变量时可以赋值为undefined。
            VariableEnvironment: { 
                VarDeclarations: {
                // var声明的变量在这里，它初始化被复值undefined。
                },
                FunctionDeclarations: {
                // 函数声明也在这里（提升效应）
                fn3: <reference to fn3 function>,
                fn1: <reference to fn1 function>,
                },
                Parameters: { // 存放函数的参数
                // 全局上下文没有参数
                },
            },
            LexicalEnvironment: { // 环境记录可以包含变量标识符与变量值之间的映射关系，以支持变量的声明和访问。
                LetConstDeclarations: {
                    // let和const声明的变量在这里
                    // let/const在初始化时会被置为<uninitialized>标志位，在没执行道let/const 声明代码块以前访问变量，会报ReferenceError错误，
                    // 这个特点被称之为暂时性死区
                    a: 0
                },
                FunctionDeclarations: {
                // 函数声明也在这里（与VariableEnvironment共享相同的记录）
                    fn3: <reference to fn3 function>,
                    fn1: <reference to fn1 function>,
                },
                Outer: null, // 这里指向父级的词法环境，形成链式查找，即作用域链 。全局上下文没有外部引用
            },
            ThisBinding: <global object> 
            // 
            // 在全局作用域中 this 在浏览器中通常是window对象，在Node.js中是global对象
            // 在函数作用域中 this 指向调用这个函数的对象   obj.fun()   func.call(obj, a, b)
            // 
        }


        作用域的定义：
            在JavaScript中，是一个规则或机制，用于确定变量的可见性和生命周期。作用域本身不是一个对象。
            1.全局作用域：
                全局作用域是整个程序的最外层作用域，包含了在程序中任何地方都可以访问的变量和函数
                全局作用域在程序启动时创建，并在程序结束时销毁。
                全局作用域通常与全局对象（例如 window 对象）关联，因此在全局作用域中声明的变量或函数可以通过全局对象来访问。
            2.函数作用域：
                函数作用域是指变量的可见性和生命周期仅限于函数内部
                函数作用域的变量在函数执行结束后会被销毁，它们不会污染外部作用域
            3.块级作用域：
                块级作用域是指变量的可见性和生命周期限定在一个代码块（通常由花括号 {} 包裹）内部。
                在ES6之前，JavaScript没有块级作用域，只有函数作用域。但ES6引入了 let 和 const 关键字，允许在块级作用域内定义变量
                块级作用域的变量在代码块执行结束后会被销毁，不会污染外部作用域

        作用域链的定义：
            是在JavaScript中用于查找变量的机制，它是一个由多个嵌套的作用域对象组成的链式结构。

            作用域链的构建是在函数的创建时确定的，它基于函数的嵌套关系和函数在哪里被定义。
            在每个函数执行时，都会创建一个执行上下文。这个执行上下文内中包含一个词法环境，词法环境记录了变量标识符和变量之间的映射关系，以便于函数执行时查找使用。
            这个词法环境里有一个outer属性指向了父级的词法环境，当当前函数在自己的词法环境里找不到变量标识符时就从outer里一级一级向上查找。

        this的定义：
            this是一个关键字。它指向了调用函数的对象（这个对象是js代码中的一个具体的对象）。
                1.全局上下文中的对象，window、global
                2.调用函数的对象实例。 可以是字面量 obj = {} 也可以是new createObj()创建的对象实例
                3.call/apply/bind 指定的对象
                4.箭头函数没有自己的this，它捕获箭头函数被定义时所在上下文中的this
            在非严格模式下，当一个函数不是作为对象的方法被调用，也没有通过call、apply或者bind方法明确指定this时，this将默认指向全局对象

        this等于作用域吗？
            this不等于作用域，是两个不同的概念。

            作用域是一套规则，用来定义变量的可见性和生命周期。作用域是通过词法环境以及它们之间的引用关系来实现的


    */


    /*
        面向对象编程和面向函数编程：
            两种不同的范式。
            面向对象编程：用对象来设计程序，通过对实例进行抽象得到类（一组拥有相同属性和对象的抽象蓝图）。
                        封装：对象的状态（数据）和行为（方法）打包在一起，对外隐藏实现细节，
                        继承：允许一个类继承另一个类的特性，促进代码重用，
                        多态：允许以不同的方式使用对象，通常是通过接口或抽象类实现。
            面向函数编程：计算视为数学函数的求值，并避免使用程序状态以及易变对象
                        纯函数：返回值只依赖于其参数，并且不产生副作用
                        不可变性： 状态不应该被修改，任何状态的变更应该产生新的状态
                        高阶函数: 接受一个或多个函数作为参数，或者返回一个函数的函数。
                        递归: 函数调用自身来处理问题

    */
}





const test_function = () => {
    
    // 立即执行的函数表达式(IIFE)的函数名称跟内部变量名称重名后，函数名称优先，因为函数名称是不可改变的，内部会静默失败，在严格模式下会报错
    (function a () {
        a = 2;
        console.log(a);
    })();

}


const this_function = () => {
    /*
        call()、apply() 和 bind() 用于改变函数执行时的 this 上下文。
        call() 和 apply() 用于立即调用函数，并设置函数执行时的 this 值。它们之间的区别在于参数传递方式：call() 通过参数列表传递，apply() 通过参数数组传递。
        bind() 方法不会立即调用函数。而是返回一个新的函数，新函数的 this 值被绑定到指定的对象，在调用新函数时，传入的参数将依次传递给原函数。
        greet.call(obj, 'Hello')
        greet.apply(obj, ['Hello']); 
        const boundGreet = greet.bind(obj);
    */

}



/*


*/