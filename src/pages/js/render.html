<html>
    <!--
        进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。
        线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。
        对于操作系统来说,一个任务就是一个进程,比如打开一个浏览器就是启动了一个浏览器进程,打开一个 Word 就启动了一个 Word 进程。
        由于每个进程至少要做一件事,所以一个进程至少有一个线程。系统会给每个进程分配独立的内存,因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段,数据集,堆等）


        浏览器进程：
            主进程：负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等
            第三方插件进程：每种类型的插件对应一个进程,仅当使用该插件时才创建。
            GPU进程：最多只有一个,用于 3D 绘制等
            渲染进程：称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。
                1.GUI渲染线程：
                    渲染浏览器界面,解析 HTML,CSS,构建 DOM 树和 RenderObject 树,布局和绘制
                    重绘/回流,该线程就会执行
                    GUI 渲染线程与 JS 引擎线程是互斥的,当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了）,GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行
                2.js引擎线程
                    js引擎线程负责解析 Javascript 脚本,运行代码
                    js引擎一直等待着任务队列中任务的到来,然后加以处理。一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
                    GUI 渲染线程与 JS 引擎线程是互斥的,所以如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞
                3.事件触发线程
                    归属于浏览器而不是 JS 引擎,用来控制事件循环（可以理解,JS 引擎自己都忙不过来,需要浏览器另开线程协助）
                    当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等）,会将对应任务添加到事件线程中
                    对应的事件符合触发条件被触发时,该线程会把事件添加到待处理队列的队尾,等待 JS 引擎的处理
                    队列中的事件都得排队等待 JS 引擎处理（
                4.定时器触发线程
                    setInterval 与 setTimeout 所在线程
                    浏览器定时计数器并不是由 JavaScript 引擎计数的，因为 JavaScript 引擎是单线程的, 
                    如果处于阻塞线程状态就会影响记计时的准确，因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中,等待 JS 引擎空闲后执行）
                5.网络请求线程
                    XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
                    将检测到状态变更时,如果设置有回调函数,异步线程就产生状态变更事件,将这个回调再放入事件队列中。再由 JavaScript 引擎执行
        
        
        为什么js是单线程？
            如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突
            假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果
            当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。
        
        为什么 JS 阻塞页面加载？
            由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了
            为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系
        
        css 加载会造成阻塞吗 ？
             CSS 加载不会阻塞 DOM 的解析，但会会阻塞 Dom 的渲染。
            DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载不会阻塞 DOM 的解析
            然而,由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的，所以他必须等待到 CSSOM Tree 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。

            由于 JavaScript 也是可操纵 css 样式 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了
            css在后面的 js 执行前先加载执行完毕,所以css 会阻塞后面 js 的执行
        
         DOMContentLoaded 与 load 的区别 ?
            DOMContentLoaded: 仅当 DOM 解析完成后,不包括css,图片等其它资源。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行
            onload: ,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕
        
        什么是 CRP,即关键渲染路径(Critical Rendering Path)? 如何优化 ?
            浏览器将HTML，CSS，JavaScript转换为屏幕上所呈现的实际像素，这期间所经历的一系列步骤，叫做关键渲染路径（Critical Rendering Path）
            dom  ----》
            cssom  ---》 render tree -》layout ---》Paint

        优化渲染？
            优化dom，删除不必要的代码和注释包括空格,尽量做到最小化文件
            优化 CSSOM，减少关键 CSS 元素数量，关注媒体查询的类型,它们极大地影响了 CRP 的性能 。
        
    -->
    <head>

    </head>
    <body>

    </body>
</html>