
/*

    pnpm 使用硬连接减少重复安装包，磁盘上只会存储一次
    运行 pnpm store path 查看储存位置 // /Users/sunyangkai/Library/pnpm/store/v3
    软连接：指向另一个文件的路径，链接到目录。
    硬链接：指向另一个文件的数据，更稳健，不能跨文件系统

    幽灵依赖：
        1.一个包的依赖项是其它包的依赖项，在package.json里没有明确声明依赖，npm会向上文件夹查找依赖。

    pnpm解决幽灵依赖问题，不再像npm那样当发现当前项目package.json未声明的包时，向父级目录寻找依赖安装。在pnpm中加载没有明确声明的依赖会报错。
    
    pnpm 并非全局安装，只是包都采用硬链接方式。是否全局安装在于其在项目中的可访问性。pnpm非全局安装的包，如果在package.json中未声明，一样不能访问。

    peer Dependencies 对等依赖。 当前包声明peer Dependencies告诉使用它的包，希望对方安装自己需要的包，自己不会再额外安装。
    npm发现当前包的peerDependencies 不存在，不会去安装对应的包，而是会给出警告，以避免版本冲突。
    开发者应该手动去安装这些依赖

    pnpm 虽然支持安装同一个包的不同版本，但是可能带来实例不统一的问题。有些包的运行需要唯一的一个实例。




    npm2:
        依赖包每个都有自己的node_modules 是嵌套的，磁盘占用空间大，重复多。windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的
    
    yarn:
        展平了嵌套node_modules。当一个包有多个版本时还是会嵌套，只会提升一个。
        幽灵依赖的问题。
    
    pnpm:
        node_modules使用软连接，而不是复制文件夹。
        所有的依赖都是从全局 store 硬连接到了 node_modules/.pnpm 下，然后之间通过软链接来相互依赖。

        全局store节省磁盘空间，软连接不用复制，快。
        对monorepo支持好

    .lock文件的作用
        yarn.lock 文件记录了项目中每个依赖项的确切版本号，包括直接依赖和间接依赖。这种版本锁定确保了每次安装依赖时都使用相同的版本，避免了意外的版本升级和不稳定性。


    解决.lock文件冲突
        1.删掉 lockfile，后面再重新安装依赖   这会导致lock文件历史记录丢失  会导致潜在的版本变更，锁定失效
        2.重置为其中一个分支的 lockfile，后面再重新安装依赖
        3.运行依赖安装命令，利用包管理工具自带的机制修复 lockfile 冲突


    冲突产生的原因：
       1. 包管理工具版本不一致导致 lockfile 的结构发生变化，出现不兼容合并。对于这个问题，我们应该限定包管理工具的版本
            解决：应该限定包管理工具的版本
       2.两个分支的 package.json 依赖配置都发生了变更，并修改了 lockfile 的同一区域。
            忽略冲突，丢弃更改
            以当前或者目标分支为基准 执行 git checkout --ours "*lock*" 或 git checkout --theirs "*lock*" 命令，将以当前分支或目标分支为基准自动修复 lockfile 冲突
            无论是以当前分支还是目标分支为基准，重置分支 lockfile 再更新依赖意味着会丢失一部分 lock 记录，可能会引发错误。
            尤其是公司的第三方业务包，质量不稳定可能也不遵循规范，建议写死版本号。

            pnpm 的冲突合并修复策略
            



    采取固定版本是否可取？
    于应用项目来说，可以直接使用固定版本；但是对于类库项目，不推荐固定版本，有以下两点原因：
        依赖该类库的应用项目无法充分复用依赖：比如 ^1.0.0 和 ^1.1.0 可以合并成 ^1.1.0）
        类库项目的间接依赖出现安全漏洞时，无法通过重新安装依赖直接修复


    版本号：
    在 Node.js 生态系统中，常用的版本规则遵循语义化版本控制（Semantic Versioning，SemVer）标准。
    一个版本号由三部分组成：主版本号、次版本号和补丁版本号。

    1. **主版本号（MAJOR）：** 当进行不兼容的 API 更改时增加，表示可能会导致现有代码不兼容。

    2. **次版本号（MINOR）：** 当添加新功能，但保持向后兼容时增加。

    3. **补丁版本号（PATCH）：** 当进行向后兼容的 bug 修复时增加。

    示例：
    - `1.0.0`：初始版本。
    - `1.2.0`：添加了新功能，向后兼容。
    - `1.2.1`：修复 bug，向后兼容。
    - `2.0.0`：不兼容的 API 更改。

    除了主、次、补丁版本号外，还可以使用一些符号和标记来指定版本范围：

    - `^`：表示兼容更新，即可以接受不破坏向后兼容性的新版本。
    - `~`：表示只接受补丁更新，即只接受相同主版本和次版本的补丁版本。
    - `>=`：表示最小允许版本。
    - `<=`：表示最大允许版本。
    - `>`：表示大于指定版本。
    - `<`：表示小于指定版本。

    示例：
    - `^1.2.0`：允许 1.2.0 及以上的版本，但不包括 2.0.0。
    - `~1.2.3`：允许 1.2.3 及以上的补丁版本，但不包括 1.3.0。
    - `>=1.2.0 <2.0.0`：允许 1.2.0 到 1.9.9 的版本。
    - `>1.0.0`：允许大于 1.0.0 的版本。

    这些规则帮助开发者指定依赖的版本范围，以确保获取合适的更新并避免不兼容性。在 `package.json` 文件中，通常使用这些规则来描述项目的依赖。
    */