

/*
    优化：

    开发环境：
        提升构建工具速度
            esbuild
        性能监测工具
    生产环境：
        网络传输：
            http1 升级为http2
                    1.多路复用。http2底层允许多个http请求/响应 建立在一个tcp连接上。http1 chrome限制同时存在6个tcp连接。
                        在丢包的时候，http2性能会比较差。由于多个http请求都建立在一个tcp连接之上，当tcp底层发生丢包的时候，后面所有http都要等待底层tcp完成重传。
                        会对服务器早上瞬时压力，因为多路复用没有限制同时请求数量。这个可以通过负载均衡解决
                    2.二进制和header压缩。http1 使用文本传输，http2使用二进制传输，解析、编码和传输更加高效。
            拆分接口
                接口一次性返回大量数据可能不是必须的。拆分为多个接口按需请求。
                接口条件查询，接口分页查询
            请求顺序
                按照业务优先级合理安排接口请求顺序。

            静态资源使用 CDN加速。
                内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。
                CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

        网络缓存：
            打包使用chunckhash，利用浏览器缓存

        资源加载：
            构建生产包压缩css、js。
            多个小图片考虑组成雪碧图。图片太小转为base64编码格式。 减少http请求
            使用字体图标 iconfont 代替图片图标
                ，字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。
                 还有一个优点是生成的文件特别小。
            fontmin-webpack压缩字体
            尽可能使用css/js特效替代图片。
            分包，反复引用多次的公共资源包可以独立拆分出来。【webpack中的splitChunk】
            动态加载，按需加载。
            服务端渲染

            不重要的js放在body底部。
            
        程序性能：
            减少重排和重绘。
                当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。
                当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排
                重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。
                
                如何减少重排重绘？
                    用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。
                    如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。
                    推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案

            提升算法性能。
            虚拟滚动列表。
            图片延迟加载。页面可见时再加载图片。
            使用事件委托。集中管理事件。
            requestAnimationFrame。实现动画。
                大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame
                如果采取 setTimeout 或 setInterval 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。
            Web Workers。开新线程处理。
            使用位操作。
                位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。

*/